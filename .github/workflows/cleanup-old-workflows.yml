name: Cleanup Old Workflow Runs

on:
  push:
    branches: ["dev", "master"]
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'  # Run every 6 hours

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    
    steps:
      - name: Delete old workflow runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // üîß CONFIGURATION
            const KEEP_DAYS = 1;              // Keep runs from the last 1 day
            const KEEP_SUCCESSFUL = 2;        // Keep the 2 latest successful runs per workflow
            const DELETE_FAILED = true;       // Delete failed runs older than KEEP_DAYS
            const DELETE_CANCELLED = true;    // Delete cancelled runs older than KEEP_DAYS
            const SLEEP_MS = 100;             // Pause between deletions (reduced for speed)
            const DRY_RUN = false;            // Set to true to see what would be deleted without deleting
            
            console.log(`üßπ Cleanup started for ${owner}/${repo}`);
            console.log(`üìÖ Keep: last ${KEEP_DAYS} day(s), ${KEEP_SUCCESSFUL} successful runs per workflow`);
            console.log(`üóëÔ∏è  Delete: failed=${DELETE_FAILED}, cancelled=${DELETE_CANCELLED}`);
            if (DRY_RUN) console.log(`‚ö†Ô∏è  DRY RUN MODE - Nothing will be deleted`);
            
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - KEEP_DAYS);
            console.log(`üìÜ Cutoff date: ${cutoffDate.toISOString()}`);
            
            // Get all workflows
            const workflows = await github.paginate(
              github.rest.actions.listRepoWorkflows,
              { owner, repo, per_page: 100 }
            );
            
            console.log(`\nüìã Found ${workflows.length} workflows\n`);
            
            let totalDeleted = 0;
            let totalKept = 0;
            let totalErrors = 0;
            
            for (const workflow of workflows) {
              console.log(`\n${'='.repeat(80)}`);
              console.log(`üîç Processing: ${workflow.name} (ID: ${workflow.id})`);
              console.log(`${'='.repeat(80)}`);
              
              let runs;
              try {
                runs = await github.paginate(
                  github.rest.actions.listWorkflowRuns,
                  { owner, repo, workflow_id: workflow.id, per_page: 100 }
                );
              } catch (error) {
                console.log(`  ‚ùå Error fetching runs: ${error.message}`);
                continue;
              }
              
              if (!runs.length) {
                console.log("  ‚ö†Ô∏è  No runs found.");
                continue;
              }
              
              // Sort by date (newest first)
              runs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              
              console.log(`  üìä Total runs: ${runs.length}`);
              
              // Track successful runs to keep
              let keptSuccessful = 0;
              const runsToDelete = [];
              const runsToKeep = [];
              
              for (const run of runs) {
                const runDate = new Date(run.created_at);
                const ageInDays = (Date.now() - runDate.getTime()) / (1000 * 60 * 60 * 24);
                const isOld = runDate < cutoffDate;
                const isCurrent = run.id === context.runId;
                
                const conclusion = run.conclusion || 'in_progress';
                const isSuccess = conclusion === 'success';
                const isFailed = conclusion === 'failure';
                const isCancelled = conclusion === 'cancelled';
                
                // Never delete current run
                if (isCurrent) {
                  runsToKeep.push({ run, reason: 'CURRENT RUN' });
                  continue;
                }
                
                // Delete old failed runs
                if (isFailed && DELETE_FAILED && isOld) {
                  runsToDelete.push({ 
                    run, 
                    reason: `FAILED + OLD (${ageInDays.toFixed(1)} days)` 
                  });
                  continue;
                }
                
                // Delete old cancelled runs
                if (isCancelled && DELETE_CANCELLED && isOld) {
                  runsToDelete.push({ 
                    run, 
                    reason: `CANCELLED + OLD (${ageInDays.toFixed(1)} days)` 
                  });
                  continue;
                }
                
                // Handle successful runs
                if (isSuccess) {
                  keptSuccessful++;
                  if (keptSuccessful <= KEEP_SUCCESSFUL) {
                    runsToKeep.push({ 
                      run, 
                      reason: `SUCCESS #${keptSuccessful}` 
                    });
                  } else if (isOld) {
                    runsToDelete.push({ 
                      run, 
                      reason: `OLD SUCCESS (${ageInDays.toFixed(1)} days, exceeds limit)` 
                    });
                  } else {
                    runsToKeep.push({ 
                      run, 
                      reason: `RECENT SUCCESS (${ageInDays.toFixed(1)} days)` 
                    });
                  }
                  continue;
                }
                
                // Keep recent runs of other statuses
                if (!isOld) {
                  runsToKeep.push({ 
                    run, 
                    reason: `RECENT (${ageInDays.toFixed(1)} days, ${conclusion})` 
                  });
                } else {
                  runsToDelete.push({ 
                    run, 
                    reason: `OLD (${ageInDays.toFixed(1)} days, ${conclusion})` 
                  });
                }
              }
              
              console.log(`\n  üìä Summary:`);
              console.log(`     ‚Ä¢ To Delete: ${runsToDelete.length}`);
              console.log(`     ‚Ä¢ To Keep:   ${runsToKeep.length}`);
              
              // Show what will be deleted
              if (runsToDelete.length > 0) {
                console.log(`\n  üóëÔ∏è  Runs to delete:`);
                for (const { run, reason } of runsToDelete.slice(0, 5)) {
                  const date = new Date(run.created_at).toISOString().split('T')[0];
                  console.log(`     ‚Ä¢ #${run.run_number} - ${date} - ${reason}`);
                }
                if (runsToDelete.length > 5) {
                  console.log(`     ... and ${runsToDelete.length - 5} more`);
                }
              }
              
              // Delete runs
              if (!DRY_RUN) {
                for (const { run, reason } of runsToDelete) {
                  try {
                    await github.rest.actions.deleteWorkflowRun({ 
                      owner, 
                      repo, 
                      run_id: run.id 
                    });
                    totalDeleted++;
                    // Only log every 10th deletion to reduce noise
                    if (totalDeleted % 10 === 0) {
                      console.log(`  üóëÔ∏è  Deleted ${totalDeleted} runs so far...`);
                    }
                    await new Promise(r => setTimeout(r, SLEEP_MS));
                  } catch (err) {
                    console.log(`  ‚ùå Failed to delete run #${run.run_number}: ${err.message}`);
                    totalErrors++;
                  }
                }
              }
              
              totalKept += runsToKeep.length;
            }
            
            // Final summary
            console.log(`\n${'='.repeat(80)}`);
            console.log(`‚úÖ CLEANUP COMPLETE`);
            console.log(`${'='.repeat(80)}`);
            console.log(`üìä Final Statistics:`);
            console.log(`   ‚Ä¢ Total Deleted: ${totalDeleted}`);
            console.log(`   ‚Ä¢ Total Kept:    ${totalKept}`);
            console.log(`   ‚Ä¢ Errors:        ${totalErrors}`);
            if (DRY_RUN) {
              console.log(`\n‚ö†Ô∏è  DRY RUN - No runs were actually deleted`);
              console.log(`   Set DRY_RUN = false to delete runs`);
            }
            console.log(`${'='.repeat(80)}\n`);
            
