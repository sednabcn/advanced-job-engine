name: Cleanup Old Workflow Runs

on:
  push:
    branches: ["dev", "master"]
  workflow_dispatch:

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read

    steps:
      - name: Delete old workflow runs (keep latest N successful)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // üîß CONFIGURATION
            const KEEP_DAYS = 1;            // Keep runs from the last 3 days
            const KEEP_SUCCESSFUL = 2;      // Keep the 5 latest successful runs
            const DELETE_FAILED = true;     // Delete all failed runs
            const SLEEP_MS = 500;           // Pause between deletions

            console.log(`üßπ Cleanup started for ${owner}/${repo}`);
            console.log(`üìÖ Keep runs from last ${KEEP_DAYS} days and last ${KEEP_SUCCESSFUL} successful runs`);

            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - KEEP_DAYS);

            const workflows = await github.paginate(
              github.rest.actions.listRepoWorkflows,
              { owner, repo }
            );

            for (const workflow of workflows) {
              console.log(`\nüîç Processing workflow: ${workflow.name} (id=${workflow.id})`);

              const runs = await github.paginate(
                github.rest.actions.listWorkflowRuns,
                { owner, repo, workflow_id: workflow.id, per_page: 100 }
              );

              if (!runs.length) {
                console.log("  ‚ö†Ô∏è No runs found.");
                continue;
              }

              // Sort by date (newest first)
              runs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

              // Keep track of successful runs
              let keptSuccessful = 0;
              const runsToDelete = [];

              for (const run of runs) {
                const runDate = new Date(run.created_at);
                const isOld = runDate < cutoffDate;
                const isFailed = run.conclusion && run.conclusion !== "success";
                const isSuccess = run.conclusion === "success";
                const isCurrent = run.id === context.runId;

                if (isCurrent) continue; // never delete current run

                if (isFailed && DELETE_FAILED) {
                  runsToDelete.push({ run, reason: `FAILED (${run.conclusion})` });
                  continue;
                }

                if (isSuccess) {
                  keptSuccessful++;
                  if (keptSuccessful > KEEP_SUCCESSFUL || isOld) {
                    runsToDelete.push({ run, reason: isOld ? `OLD (${KEEP_DAYS}+ days)` : "EXCEEDS keep limit" });
                  }
                }
              }

              console.log(
                `  üìä Total: ${runs.length} | Deleting: ${runsToDelete.length} | Keeping: ${
                  runs.length - runsToDelete.length
                }`
              );

              for (const { run, reason } of runsToDelete) {
                try {
                  await github.rest.actions.deleteWorkflowRun({ owner, repo, run_id: run.id });
                  console.log(`  üóëÔ∏è Deleted run #${run.run_number} [${reason}]`);
                  await new Promise(r => setTimeout(r, SLEEP_MS));
                } catch (err) {
                  console.log(`  ‚ùå Could not delete run #${run.run_number}: ${err.message}`);
                }
              }
            }

            console.log("\n‚úÖ Cleanup completed successfully.");
